<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topic N - Data Structures and Algorithms</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="../../dsa-hub.ico" type="image/x-icon">

</head>
<body>

    <div class="container">
        <!-- Topic Title -->
        <h1>Rekursiya: O'z-o'ziga murojaat qilish</h1>
        <h2><b><strong class="GFGEditorTheme__textUnderline">Rekursiyaning ta'rifi</strong></b></h2>
        <!-- Description Section -->
        <section class="description">
            <p><strong>Rekursiya so'zining ma'nosi:</strong> Rekursiya so'zining ma'nosi: "Biror muammoni hal qilish uchun, masalan, o'z-o'zini chaqirish yoki avvalgi natijalarni qayta ishlash orqali takroriy jarayonni amalga oshirish" yoki "Muammoni hal qilish jarayonida funksiya yoki algoritmning o'zini o'zi chaqirishi, odatda ma'lum bir asosiy shart yoki holatga erishguncha davom etadi".</p>
        </section>

        <!-- Image Section -->
        <section class="media">
            <h2>Illustration</h2>
            <img src="images/recursion_1.1.png" alt="Topic N Illustration" class="topic-image">
        </section>

        
        <section class="description">
            <p dir="ltr"><span>Funksiya o'zini to'g'ridan-to'g'ri yoki bilvosita chaqiradigan jarayon rekursiya deb ataladi va mos keluvchi funksiya rekursiv funksiya deb nomlanadi.</span></p>
            <ul>
                <li value="1"><span>Rekursiv algoritm yechimga yaqinlashish uchun bir qadam bajaradi, keyin yana o'zini chaqirib davom etadi. Algoritm yechimga erishganimizda to'xtaydi.</span></li>
                <li value="2"><span>Chaqirilgan funksiya yana o'zini chaqirishi mumkinligi sababli, bu jarayon cheksiz davom etishi mumkin. Shuning uchun rekursiyani to'xtatish uchun asosiy holatni taqdim etish muhimdir.</span></li>
            </ul>
            <p dir="ltr"><b><strong>Rekursiyaning zarurati</strong></b></p>
        </section>
        <div id="GFG_AD_gfg_mobile_336x280"></div>
        <section class="description">
            <ul>
                <li value="1"><span>Rekursiya mantiqni rivojlantirishga yordam beradi. Rekursiv fikrlash murakkab muammolarni kichikroq muammolarga ajratish orqali yechishda yordam beradi.</span></li>
                <li value="2"><span>Rekursiv yechimlar Dynamic Programming va Divide and Conquer algoritmlarining asosi bo'lib xizmat qiladi.</span></li>
                <li value="3"><span>Ba'zi muammolarni rekursiya yordamida juda oson yechish mumkin, masalan, </span><a href="https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/" rel="noopener"><span>Hanoi minoralari (TOH)</span></a><span>, </span><a href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/" rel="noopener"><span>Daraxtlarni Inorder/Preorder/Postorder bo'yicha aylanib chiqish</span></a><span>, </span><a href="https://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/" rel="noopener"><span>Grafning DFS (Depth First Search)</span></a><span> kabi.</span></li>
            </ul>
        </section>        

        <h4><span>Qadamlar</span></h4>
        <section class="description">
            <blockquote>
                <p dir="ltr"><span>1-qadam – Asosiy holatni aniqlang: Eng oddiy (yoki asosiy) holatni aniqlang, bu holatda yechim ma'lum yoki oddiy bo'ladi. Bu rekursiyani to'xtatish shartidir va funksiyaning cheksiz o'zini chaqirishining oldini oladi.</span><br><br>
                <span>2-qadam – Rekursiv holatni aniqlang: Muammoni kichikroq submuammolar shaklida aniqlang. Muammoni o'zining kichikroq versiyalariga bo'ling va har bir submuammoni hal qilish uchun funksiyani rekursiv chaqiring.</span><br><br>
                <span>3-qadam – Rekursiya tugashini ta'minlang: Rekursiv funksiya oxir-oqibat asosiy holatga yetishini va cheksiz aylanishga tushmasligini ta'minlang.</span><br><br>
                <span>4-qadam – Yechimlarni birlashtiring: Asl muammoni hal qilish uchun submuammolarning yechimlarini birlashtiring.</span></p>
            </blockquote>
            <p dir="ltr"><b><strong>Misol 1: Natural sonlar yig'indisi</strong></b></p>
            <p dir="ltr"><span>Natural sonlar yig'indisini topish muammosini ko'rib chiqamiz. Buni hal qilishning bir nechta usullari mavjud, ammo eng oddiy yondashuv bu sonlarni 0 dan n gacha qo'shishdir. Shunday qilib, funksiya quyidagicha ko'rinishda bo'ladi:</span></p>
            <blockquote>
                <p dir="ltr"><b><strong>yondashuv(1) – Birma-bir qo'shish</strong></b></p>
                <p dir="ltr"><b><strong>f(n) = 0 + 1 + 2 + 3 + …… + n</strong></b></p>
            </blockquote>
            <p dir="ltr"><span>Lekin buni ifodalashning yana bir matematik yondashuvi mavjud:</span></p>
            <blockquote>
                <p dir="ltr"><b><strong>yondashuv(2) – Rekursiv qo'shish</strong></b></p>
                <p dir="ltr"><b><strong>f(n) = 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n=0</strong></b></p>
                <p dir="ltr"><b><strong>f(n) = n + f(n-1) &nbsp; &nbsp;n&gt;=1</strong></b></p>
            </blockquote>
        </section>
        
        <section class="code">
            <pre><code>// Recursive function to find the sum of 
// numbers from 0 to n
function findSum(n) {

    // Base case 
    if (n === 0) 
        return 0; 
    
    // Recursive case 
    return n + findSum(n - 1);
}

let n = 5;
console.log(findSum(n));</code></pre>
        </section>

        <div class="code-output"><br><strong>Natija</strong>
            <pre style="position: relative;">15<div class="open_grepper_editor" title="Tahrirlash va Saqlash"></div></pre>
        </div>
        <section class="description">
            <p dir="ltr"><b><strong>Rekursiyada asosiy shart (base condition) nima?</strong></b><span>&nbsp;</span><br>
            <span>Rekursiv dastur asosiy shartda to'xtaydi. Rekursiyada bir yoki undan ko'p asosiy shartlar bo'lishi mumkin. Yuqoridagi dasturda asosiy shart n = 1 bo'lgan holatdir.</span></p>
            <p dir="ltr"><b><strong>Qanday qilib rekursiya yordamida muammo hal qilinadi?</strong></b><span>&nbsp;</span><br>
            <span>Asosiy g'oya muammoni bir yoki bir nechta kichik muammolar shaklida ifodalashdir va rekursiyani to'xtatadigan bir yoki bir nechta asosiy shartlarni qo'shishdir.&nbsp;</span></p>
            <p dir="ltr"><b><strong>Misol 2: Sonning Faktoriali</strong></b><br>
            <span>Faktorial</span><span> son n (bu yerda n ≥ 0) uchun 1 dan n gacha bo'lgan sonlarning ko'paytmasi sifatida aniqlanadi. Rekursiv hisoblashda, agar (n-1) faktorialini bilsak, biz n faktorialini hisoblay olamiz. Faktorial uchun asosiy holat n = 0 bo'ladi. n = 0 bo'lganda 1 qaytaramiz.&nbsp;</span></p>
        </section>
        
        <section class="code">
            <pre><code>function fact(n) {

    // BASE CONDITION
    if (n === 0)
        return 1;
    
    return n * fact(n - 1);
}

console.log("Factorial of 5 : " + fact(5));</code></pre>
        </section>

        <div class="code-output"><br><strong>Natija</strong><pre style="position: relative;">5 sonining faktoriali: 120<div class="open_grepper_editor" title="Tahrirlash va Saqlash"></div></pre></div>
<section class="description">
    <p dir="ltr"><b><strong>Yuqoridagi kodning izohi:</strong></b></p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240924132748/factorial.webp" alt="faktorial" class="topic-image">
    <p dir="ltr"><b><strong>Rekursiyada Stack Overflow xatosi qachon yuzaga keladi?</strong></b><span>&nbsp;</span><br><span>Agar asosiy shart (base case) to'g'ri belgilangan yoki unga erishilgan bo'lmasa, stack overflow muammosi yuzaga kelishi mumkin. Bu tushunchani tushunish uchun bir misolni ko'rib chiqamiz.</span></p>
        </section>
        <pre style="position: relative;"><span>function fact(n) {</span><br>
        <span>    // noto'g'ri asosiy shart (bu stack overflowga olib kelishi mumkin).</span><br>
        <span>    if (n === 100)</span><br>
        <span>        return 1;</span><br><br>
        <span>    else</span><br>
        <span>        return n * fact(n - 1);</span><br>
        <span>}</span>
        </pre>
        <section class="description">
            <p dir="ltr"><span>Agar <code>fact(10)</code> chaqirilsa, u <code>fact(9)</code>, <code>fact(8)</code>, <code>fact(7)</code> kabi chaqiruvlarni davom ettiradi, lekin qiymat hech qachon 100 ga yetmaydi. Shunday qilib, asosiy shart bajarilmaydi. Agar stackdagi funksiyalar xotirani to'ldirib yuborsa, stack overflow xatosi yuzaga keladi.&nbsp;</span></p>
            <p dir="ltr"><b><strong>To'g'ridan-to'g'ri va bilvosita rekursiya o'rtasidagi farq nima?</strong></b><span>&nbsp;</span><br><span>Agar biror funksiya o'zini o'zi chaqirsa, u to'g'ridan-to'g'ri rekursiv deyiladi. Agar funksiya boshqa funksiyani (masalan, <code>fun_new</code>) chaqirsa va <code>fun_new</code> yana o'sha dastlabki funksiyani chaqirsa, u bilvosita rekursiya deb ataladi. To'g'ridan-to'g'ri va bilvosita rekursiya o'rtasidagi farq 1-jadvalda ko'rsatilgan.&nbsp;</span></p>
        </section>

        <pre style="position: relative;"><b><strong>// To'g'ridan-to'g'ri rekursiya misoli</strong></b><br><span>void directRecFun()</span><br><span>{</span><br><span>    // Ba'zi kodlar...</span><br><br><span>    directRecFun();</span><br><br><span>    // Ba'zi kodlar...</span><br><span>}</span><br><br><b><strong>// Bilvosita rekursiya misoli</strong></b><br><span>void indirectRecFun1()</span><br><span>{</span><br><span>    // Ba'zi kodlar...</span><br><br><span>    indirectRecFun2();</span><br><br><span>    // Ba'zi kodlar...</span><br><span>}</span><br><span>void indirectRecFun2()</span><br><span>{</span><br><span>    // Ba'zi kodlar...</span><br><br><span>    indirectRecFun1();</span><br><br><span>    // Ba'zi kodlar...</span><br><span>}</span></pre>
        <section class="description">
            <p dir="ltr"><b><strong>Dumli (tail) va dumli bo'lmagan rekursiya o'rtasidagi farq nima?</strong></b><span>&nbsp;</span><br><span>Rekursiv funksiya dumli rekursiya deyiladi, agar rekursiv chaqiriq funksiya bajaradigan oxirgi narsa bo'lsa. Batafsil ma'lumot uchun </span><a href="https://www.geeksforgeeks.org/tail-recursion/" rel="noopener"><span>dumli rekursiya maqolasiga</span></a><span> murojaat qiling.&nbsp;</span></p>
            <p dir="ltr"><b><strong>Rekursiyada turli funksiyalar chaqiruvlari uchun xotira qanday ajratiladi?</strong></b><span>&nbsp;</span><br><span>Rekursiya har bir chaqiriq uchun ichki funksiya chaqiruv stekida qo'shimcha xotira talab qiladi.</span></p>
            <ul>
                <li value="1"><span>Funksiya chaqirilganda, uning yozuvi stekka qo'shiladi va chaqiriq tugaguncha stekda qoladi. </span></li>
                <li value="2"><span>Ichki tizimlar LIFO (birinchi chiqadigan oxirgi kirgan) tuzilishiga amal qilgani uchun stekdan foydalanadi; oxirgi chaqirilgan funksiya birinchi tugaydi.</span></li>
            </ul>
            <p dir="ltr"><span>Main() funksiyasidan biror funksiya chaqirilganda, unga xotira stekda ajratiladi. Rekursiv funksiya o'zini o'zi chaqirganda, chaqirilgan funksiya uchun xotira chaqiruvchi funksiyaga ajratilgan xotiraning ustiga joylashadi va har bir chaqiriq uchun mahalliy o'zgaruvchilarning alohida nusxasi yaratiladi. Asosiy shartga (base case) erishilganda, funksiya qiymatni qaytaradi, xotira bo'shatiladi va jarayon davom etadi.</span><br><span>Keling, oddiy bir funksiya yordamida rekursiya qanday ishlashini tushunamiz.&nbsp;</span></p>
        </section>

        <section class="code">
            <pre><code>// A JavaScript program to demonstrate working of recursion
function printFun(test) {
    if (test < 1)
        return;
    else {
        console.log(test);
        printFun(test - 1); // statement 2
        console.log(test);
        return;
    }
}

// Driver Code
let test = 3;
printFun(test);</code></pre>
        </section>

        <section class="description">
            <div class="code-output"><br><strong>Natija</strong><pre style="position: relative;">3 2 1 1 2 3 <div class="open_grepper_editor" title="Tahrirlash &amp; Saqlash"></div></pre></div>
            <p dir="ltr"><span>Qachonki </span><b><strong>printFun(3)</strong></b><span> asosiy dasturdan chaqirilsa, </span><b><strong>printFun(3)</strong></b><span> uchun xotira ajratiladi va mahalliy o'zgaruvchi "test" 3 ga teng qilib boshlang'ich qiymat oladi. 1 dan 4-gacha bo'lgan bayonotlar stack (steck xotira) ga qo'shiladi, quyidagi diagrammada ko'rsatilganidek. Avval "3" chop etiladi. 2-bayonotda </span><b><strong>printFun(2)</strong></b><span> chaqiriladi va xotira </span><b><strong>printFun(2)</strong></b><span> uchun ajratiladi, mahalliy o'zgaruvchi "test" 2 ga teng qilib boshlang'ich qiymat oladi va 1 dan 4-gacha bo'lgan bayonotlar stack ga qo'shiladi. Xuddi shunday, </span><b><strong>printFun(2)</strong></b><span> </span><b><strong>printFun(1)</strong></b><span> ni chaqiradi, va </span><b><strong>printFun(1)</strong></b><span> </span><b><strong>printFun(0)</strong></b><span> ni chaqiradi. </span><b><strong>printFun(0)</strong></b><span> agar shartiga o'tadi va </span><b><strong>printFun(1)</strong></b><span> ga qaytadi. Qolgan bayonotlar </span><b><strong>printFun(1)</strong></b><span> bajariladi va u </span><b><strong>printFun(2)</strong></b><span> ga qaytadi va hokazo. Natijada, 3 dan 1 gacha bo'lgan qiymatlar chop etiladi, keyin esa 1 dan 3 gacha bo'lgan qiymatlar qayta chop etiladi. Xotira stack (steck) quyidagi diagrammada ko'rsatilgan.</span></p>
            <p dir="ltr"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/recursion.jpg" alt="rekursiya" class="topic-image" loading="lazy"></p>
            <p dir="ltr"><b><strong>Rekursiya va Iteratsiya</strong></b></p>
            <table>
                <thead></thead>
                <tbody>
                    <tr>
                        <td><b><strong>№</strong></b></td>
                        <td><b><strong>Rekursiya</strong></b></td>
                        <td><b><strong>Iteratsiya</strong></b></td>
                    </tr>
                    <tr>
                        <td><span>1)</span></td>
                        <td><span>Asosiy shart bajarilganda yakunlanadi.</span></td>
                        <td><span>Loop (takrorlash) sharti bajarilmaganda yakunlanadi.</span></td>
                    </tr>
                    <tr>
                        <td><span>2)</span></td>
                        <td><span>Mantiq kichikroq muammolar asosida quriladi.</span></td>
                        <td><span>Mantiq biror narsa ustida iteratsiya qilish orqali quriladi.</span></td>
                    </tr>
                    <tr>
                        <td><span>3)</span></td>
                        <td><span>Har bir rekursiv chaqiruv uchun stack (steck) xotirasida qo'shimcha joy kerak bo'ladi.</span></td>
                        <td><span>Har bir iteratsiya qo'shimcha xotira talab qilmaydi.</span></td>
                    </tr>
                    <tr>
                        <td><span>4)</span></td>
                        <td><span>Kichikroq kod hajmi.</span></td>
                        <td><span>Katta kod hajmi.</span></td>
                    </tr>
                </tbody>
            </table>
            <p dir="ltr"><b><strong>Misol 4: Fibonacci rekursiya bilan</strong></b><br><span>n ≥ 0 bo'lganda Fibonacci qatorini topish uchun dastur va qayta yozish munosabatini yozing.&nbsp;</span><br><i><em class="GFGEditorTheme__textItalic">Matematik tenglama:</em></i><span>&nbsp;&nbsp;</span></p>
        </section>
        <pre style="position: relative;"><span>n agar n == 0, n == 1 bo'lsa;      </span><br><span>fib(n) = fib(n-1) + fib(n-2) aks holda;</span><div class="open_grepper_editor" title="Tahrirlash &amp; Saqlash"></div></pre>
        <p dir="ltr"><i><em class="GFGEditorTheme__textItalic">Qayta yozish munosabati:</em></i><span>&nbsp;</span></p>
        <pre style="position: relative;"><span>T(n) = T(n-1) + T(n-2) + O(1)</span><div class="open_grepper_editor" title="Tahrirlash &amp; Saqlash"></div></pre>
        
        <section class="code">
            <pre><code>// Function for fibonacci
function fib(n) {
    // Stop condition
    if (n === 0) return 0;

    // Stop condition
    if (n === 1 || n === 2) return 1;

    // Recursion function
    return fib(n - 1) + fib(n - 2);
}

// Driver Code
let n = 5;
console.log("Fibonacci series of 5 numbers is:");

// for loop to print the fibonacci series.
for (let i = 0; i < n; i++) {
    console.log(fib(i) + " ");
}</code></pre>
        </section>
        
        <section class="description">
            <div class="code-output"><br><strong>Natija</strong><pre style="position: relative;">Fibonacci qatorining 5 ta soni: 0 1 1 2 3 <div class="open_grepper_editor" title="Tahrirlash &amp; Saqlash"></div></pre></div>
            <p dir="ltr"><b><strong>Yuqoridagi kod uchun Rekursiya daraxti:</strong></b></p>
            <img src="https://media.geeksforgeeks.org/wp-content/uploads/20220815013010/fibonaci.jpg" alt="fibonacci" class="topic-image" srcset="https://media.geeksforgeeks.org/wp-content/uploads/20220815013010/fibonaci-100x56.jpg 100w,https://media.geeksforgeeks.org/wp-content/uploads/20220815013010/fibonaci-200x113.jpg 200w,https://media.geeksforgeeks.org/wp-content/uploads/20220815013010/fibonaci-300x169.jpg 300w" loading="lazy">
            <p dir="ltr"><br></p>
        </section>        

        <h3><span>Misol: &nbsp; Rekursiyaning haqiqiy muammolarda qo'llanilishi</span></h3>
        <section class="description">
            <p dir="ltr"><span>Rekursiya – bu kompyuter fanlari va dasturlashda keng qo'llaniladigan kuchli usul. Quyida rekursiyaning ba'zi keng tarqalgan qo'llanishlari keltirilgan:</span></p>
            <ul>
                <li value="1"><b><strong> Daraxt va grafni o‘rganish</strong></b><span>: Rekursiya daraxtlar va graf kabi ma'lumotlar strukturalarini o'rganish va qidirish uchun tez-tez ishlatiladi. Rekursiv algoritmlar daraxt yoki grafning barcha tugunlarini yoki nuqtalarini tizimli tarzda o'rganish uchun ishlatilishi mumkin.</span></li>
                <li value="2"><b><strong> Saralash algoritmlari</strong></b><span>: Rekursiv algoritmlar shuningdek, quicksort va merge sort kabi saralash algoritmlarida ham ishlatiladi. Ushbu algoritmlar ma'lumotlarni kichikroq kichik massivlar yoki ro‘yxatlarga bo‘lib, ularni saralab, so‘ngra birlashtiradi.</span></li>
                <li value="3"><b><strong> Bo'lish va zabt etish algoritmlari</strong></b><span>: Ko‘p algoritmlar bo‘lish va zabt etish yondashuvini qo‘llaydi, masalan, binar qidiruv algoritmi. Ushbu algoritmlar muammoni kichikroq sub-muammolarga bo‘lish uchun rekursiyani ishlatadi.</span></li>
                <li value="4"><b><strong> Fraktallarni yaratish</strong></b><span>: Fraktal shakllar va naqshlar rekursiv algoritmlar yordamida yaratilishi mumkin. Masalan, Mandelbrot to'plami, kompleks sonlarga rekursiv formula qo'llanilishi orqali hosil bo'ladi.</span></li>
                <li value="5"><b><strong> Orqaga qaytish algoritmlari</strong></b><span>: Orqaga qaytish algoritmlari qarorlar ketma-ketligini qabul qilishni talab qiladigan muammolarni hal qilishda qo'llaniladi, bunda har bir qaror avvalgi qarorlarga bog'liq bo'ladi. Bu algoritmlar barcha mumkin bo‘lgan yo‘llarni o‘rganish va yechim topilmaganda orqaga qaytish uchun rekursiyani ishlatishi mumkin.</span></li>
                <li value="6"><b><strong> Memoriyalash</strong></b><span>: Memoriyalash – bu qimmatbaho funksiyalarni chaqirish natijalarini saqlash va bir xil kirishlar yana yuzaga kelganda, keshda saqlangan natijani qaytarish usulidir. Memoriyalash rekursiv funktsiyalar yordamida sub-muammolar natijalarini hisoblash va keshga saqlash orqali amalga oshirilishi mumkin.</span></li>
            </ul>
            <p dir="ltr"><span>Bu rekursiyaning kompyuter fanlari va dasturlashda qo'llanilishining faqat bir nechta misollaridir. Rekursiya – bu ko‘plab turli muammolarni hal qilish uchun ishlatilishi mumkin bo‘lgan moslashuvchan va kuchli vositadir.</span></p>
            <p dir="ltr"><b><strong>Rekursiv dasturlashning iterativ dasturlashga nisbatan kamchiliklari nimalar?</strong></b><span>&nbsp;</span><br><span>Eslatma, har bir rekursiv dasturni iterativ tarzda yozish mumkin va aksincha ham to'g'ri.</span></p>
            <ul>
                <li value="1"><span>Rekursiv dasturlar odatda ko'proq xotira talab qiladi va rekursiv chaqiruvlar stekini saqlash uchun ko'proq vaqt talab qiladi.</span></li>
                <li value="2"><span>Rekursiya kodni tushunishni va xatolarni tuzatishni qiyinlashtirishi mumkin, chunki bu bir nechta funktsiyalar chaqiruvlarini o‘ylab ko‘rishni talab qiladi.</span></li>
            </ul>
            <p dir="ltr"><b><strong>Rekursiv dasturlashning iterativ dasturlashga nisbatan afzalliklari nimalar?</strong></b><span>&nbsp;</span></p>
            <ul>
                <li value="1"><span>Rekursiya kod yozishning toza va oddiy usulini taqdim etadi.</span></li>
                <li value="2"><span>Ba'zi muammolar o‘z-uzidan rekursivdir, masalan </span><a href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/" target="_blank" rel="noopener"><span>daraxtni o‘rganish</span></a><span>, </span><a href="https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/" rel="noopener"><span>Tower of Hanoi</span></a><span> va boshqalar. Bunday muammolar uchun rekursiv kod yozish afzalroqdir. Biz bunday kodlarni stek ma'lumotlar tuzilmasidan yordam olgan holda iterativ tarzda ham yozishimiz mumkin. Misol uchun </span><a href="https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/" rel="noopener"><span>Inorder Tree Traversal without Recursion</span></a><span>, </span><a href="https://www.geeksforgeeks.org/iterative-tower-of-hanoi/" rel="noopener"><span>Iterative Tower of Hanoi</span></a><span>.</span></li>
            </ul>
        </section>

        <section class="description">
            <p dir="ltr"><b><strong>Rekursiyaning xulosasi:</strong></b></p>
            <ul>
                <li value="1"><span>Rekursiyada ikkita turdagi holatlar mavjud: rekursiv holat va asosiy holat.</span></li>
                <li value="2"><span>Asosiy holat, rekursiv funksiyani tugatish uchun ishlatiladi, agar holat to'g'ri bo'lsa.</span></li>
                <li value="3"><span>Har bir rekursiv chaqiruv metodning yangi nusxasini stek xotirasida yaratadi.</span></li>
                <li value="4"><span>Cheksiz rekursiya stek xotirasining tugashiga olib kelishi mumkin.</span></li>
                <li value="5"><span>Rekursiv algoritmlar misollari: Merge Sort, Quick Sort, Tower of Hanoi, Fibonacci Series, Factorial Problem va boshqalar.</span></li>
            </ul>
        </section>        
    

           
        <!-- Video Section -->
        <section class="media">
            <h2>Video Explanation</h2>
            <div class="video-wrapper">
                <iframe 
                    class="topic-video" 
                    src="https://www.youtube.com/embed/gRPjhcg1mlE" 
                    frameborder="0" 
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                    allowfullscreen>
                </iframe>
            </div>
        </section>

    </section>
    <section class="code">
        <h2>Recursion Code Example</h2>
        <pre>
<code>function countDown(number) {
    // Bazaviy holat (rekursiyaning to'xtash sharti)
    if (number <= 0) {
      console.log("Tugatildi!");
      return;
    }
  
    // Hozirgi sonni konsolga chiqarish
    console.log(number);
  
    // Rekursiv chaqiriq (funksiya o'zini chaqiradi)
    countDown(number - 1);
  }
  
  // Misol: 5 dan 1 gacha sonlarni chiqarish
  countDown(5);
  </code></pre>
    </section>

        <!-- Additional Resources Section -->
        <section class="resources">
            <h2>Additional Resources</h2>
            <ul>
                <li><a href="docs/4-dars. Selection Sort and Recursion.pptx" download>Download Presentation</a></li>
                <li><a href="docs/4-topshiriq.docx" download>Download Task PDF</a></li>
            </ul>
        </section>

        <!-- Powered By Text -->
        <footer>
            <p class="powered-by">Powered by AdamsJames</p>
        </footer>
    </div>

    <script src="script.js"></script>
</body>
</html>
